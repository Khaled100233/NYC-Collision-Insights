# -*- coding: utf-8 -*-
"""Project DE .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pBfh5A4PvMV-lDkhqPVc-SXlDJdgy6eJ
"""

# -*- coding: utf-8 -*-
"""DE_GIU.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RYAihLnV2Y-T-s2xO6sWwAGxapZXFO2v
"""
# ---------------------------------------
### 1. Imports
# ---------------------------------------

import pandas as pd
import numpy as np
# import matplotlib.pyplot as plt
# import seaborn as sns
import os

from dash import Dash, html, dcc, Input, Output, clientside_callback, callback
import plotly.express as px
import dash_bootstrap_components as dbc
from dash_bootstrap_templates import load_figure_template

# The following notebook-style pip install command is invalid in a plain .py file.
# If you need to install dependencies, run the pip command in your shell or uncomment
# the programmatic installer below.
#
# Example shell command (run in terminal, not in this .py file):
# pip install dash dash-bootstrap-components dash-bootstrap-templates
#
# Optional programmatic installer (uncomment to enable):
# import sys, subprocess
# subprocess.check_call([sys.executable, "-m", "pip", "install", "--quiet",
#                        "dash", "dash-bootstrap-components", "dash-bootstrap-templates"])
#
#print("=> Done installing dash requirements.")

# ---------------------------------------
### 2. Load/Prepare Data
# ---------------------------------------

pd.set_option('display.max_columns', None)
# plt.style.use('seaborn-v0_8')

print("Libraries loaded successfully.")

"""### Load the Crashes"""

crashes_url = "https://data.cityofnewyork.us/api/views/h9gi-nx95/rows.csv?accessType=DOWNLOAD"

print("Loading crashes dataset")

df_crashes = pd.read_csv(crashes_url, low_memory=False)

print("Crashes dataset shape:", df_crashes.shape)
df_crashes.head()

"""### Load Persons (CHUNKED)"""

persons_url = "https://data.cityofnewyork.us/api/views/f55k-p6yu/rows.csv?accessType=DOWNLOAD"

# Only columns needed for integration
useful_cols = [
    "COLLISION_ID",
    "PERSON_TYPE",
    "PERSON_INJURY",
    "PERSON_AGE",
    "PERSON_SEX"
]

chunk_size = 200_000  # safe for free Colab
persons_chunks = []

print("Loading PERSONS dataset in chunks...")

for chunk in pd.read_csv(persons_url, usecols=useful_cols, chunksize=chunk_size, low_memory=False):
    persons_chunks.append(chunk)

# Concatenate all chunks into one DataFrame
df_persons = pd.concat(persons_chunks, ignore_index=True)

print("Persons dataset loaded successfully.")
print("Persons dataset shape:", df_persons.shape)
df_persons.head()

"""### Clean Column Names"""

df_crashes.columns = df_crashes.columns.str.upper().str.replace(" ", "_")
df_persons.columns = df_persons.columns.str.upper().str.replace(" ", "_")

df_crashes.head()

"""### Convert Date & Time Columns"""

df_crashes["CRASH_DATE"] = pd.to_datetime(df_crashes["CRASH_DATE"], errors="coerce")
df_crashes["CRASH_TIME"] = pd.to_datetime(df_crashes["CRASH_TIME"], format="%H:%M", errors="coerce").dt.time

df_crashes["YEAR"] = df_crashes["CRASH_DATE"].dt.year
df_crashes["MONTH"] = df_crashes["CRASH_DATE"].dt.month

df_crashes.head()

"""### **EDA**"""

# plt.figure(figsize=(10,5))
# df_crashes['YEAR'].value_counts().sort_index().plot(kind='bar')
# plt.title("Crashes Per Year")
# plt.xlabel("Year")
# plt.ylabel("Count")
# plt.show()

# plt.figure(figsize=(8,5))
# df_crashes['BOROUGH'].fillna('Unknown').value_counts().plot(kind='bar')
# plt.title("Crashes by Borough")
# plt.xlabel("Borough")
# plt.ylabel("Count")
# plt.show()

"""### Pre-Integration Cleaning

***Handle Missing Values***
"""

# Drop crashes with no location at all
df_crashes = df_crashes[
    ~(df_crashes["LATITUDE"].isna() & df_crashes["LONGITUDE"].isna())
].copy()

# Borough
df_crashes["BOROUGH"] = df_crashes["BOROUGH"].fillna("Unknown")

# Injury columns
injury_cols = [c for c in df_crashes.columns if "INJURED" in c or "KILLED" in c]

for col in injury_cols:
    df_crashes[col] = pd.to_numeric(df_crashes[col], errors="coerce").fillna(0).astype("int16")

"""***Remove Duplicates***"""

before = df_crashes.shape[0]
df_crashes = df_crashes.drop_duplicates(subset=["COLLISION_ID"])
after = df_crashes.shape[0]

print(f"Removed {before - after} duplicate rows.")

"""### Integration

*join crashes with persons using COLLISION_ID*
"""

# We use LEFT JOIN to Keep all crashes


df_merged = df_crashes.merge(
    df_persons,
    on="COLLISION_ID",
    how="left"
)

print("Merged dataset shape:", df_merged.shape)
df_merged.head()

"""### **Post-Integration Cleaning**"""

df_merged["PERSON_TYPE"] = df_merged["PERSON_TYPE"].fillna("Unknown").str.title()
df_merged["PERSON_INJURY"] = df_merged["PERSON_INJURY"].fillna("Unknown")
df_merged["PERSON_SEX"] = df_merged["PERSON_SEX"].fillna("Unknown")
df_merged["PERSON_AGE"] = df_merged["PERSON_AGE"].fillna(-1).astype("int16")  # -1 = missing age

"""### Memory Optimization (Downcasting)"""

# Downcasting numeric columns to reduce RAM usage
# ---------------------------------------
### 3. functions used by the app
# ---------------------------------------

def downcast_int(df):
    for col in df.select_dtypes(include=["int", "int64"]).columns:
        df[col] = pd.to_numeric(df[col], downcast="integer")
    return df

def downcast_float(df):
    for col in df.select_dtypes(include=["float"]).columns:
        df[col] = pd.to_numeric(df[col], downcast="float")
    return df

df_merged = downcast_int(df_merged)
df_merged = downcast_float(df_merged)

print("Memory optimization complete.")

"""### Save Final Cleaned Dataset"""

df_merged.to_csv("cleaned_nyc_crashes.csv", index=False)
print("Final cleaned dataset saved as cleaned_nyc_crashes.csv")
df_merged.head()

df_merged.head()





# ---------------------------------------
# Load your integrated dataset
# df_merged must already be prepared
# ---------------------------------------

# Example: You already created df_merged before this script
# Just make sure it exists in memory here

# Filter rows that have valid coordinates (recommended)
df_plot = df_merged[
    ~(df_merged["LATITUDE"].isna() | df_merged["LONGITUDE"].isna())
].copy()

# If injury column exists (adjust if needed)
injury_column = "NUMBER_OF_PERSONS_INJURED"
if injury_column not in df_plot.columns:
    raise ValueError(f"Column '{injury_column}' not found in df_merged!")

load_figure_template(["minty", "minty_dark"])

# ---------------------------------------
### 4. Build Dash App
# ---------------------------------------

app = Dash(__name__, external_stylesheets=[dbc.themes.MINTY, dbc.icons.FONT_AWESOME])

color_mode_switch = html.Span(
    [
        dbc.Label(className="fa fa-moon", html_for="switch"),
        dbc.Switch(id="switch", value=False, className="d-inline-block ms-1", persistence=True),
        dbc.Label(className="fa fa-sun", html_for="switch"),
    ]
)

app.layout = dbc.Container(
    [
        html.Div(["NYC Collision Integrated Data Visualization"],
                  className="bg-primary text-white h3 p-2"),

        color_mode_switch,

        # Dropdown to choose borough (optional)
        dbc.Row([
            dbc.Col(
                dcc.Dropdown(
                    id="borough-filter",
                    options=[{"label": b, "value": b} for b in sorted(df_plot["BOROUGH"].unique())],
                    placeholder="Select Borough (optional)",
                    clearable=True,
                ),
                width=4
            )
        ], className="my-2"),

        dcc.Graph(id="graph", className="border"),
    ]
)

# ---------------------------------------
### 5. Figure Callback
# ---------------------------------------
@callback(
    Output("graph", "figure"),
    Input("switch", "value"),
    Input("borough-filter", "value"),
)
def update_figure_template(switch_on, borough):

    template = "minty" if switch_on else "minty_dark"

    # Filter by borough if selected
    dff = df_plot.copy()
    if borough:
        dff = dff[dff["BOROUGH"] == borough]

    # Build scatter plot of collisions
    fig = px.scatter(
        dff,
        x="LONGITUDE",
        y="LATITUDE",
        size=injury_column,
        color="BOROUGH",
        hover_data=["COLLISION_ID", "PERSON_TYPE", "PERSON_INJURY"],
        template=template,
        size_max=40,
        title="Collision Map by Injury Count",
    )

    fig.update_layout(height=650)

    return fig


# ---------------------------------------
# Client-side Theme Switch
# ---------------------------------------
clientside_callback(
    """
    (switchOn) => {
       switchOn
         ? document.documentElement.setAttribute('data-bs-theme', 'light')
         : document.documentElement.setAttribute('data-bs-theme', 'dark')
       return window.dash_clientside.no_update
    }
    """,
    Output("switch", "id"),
    Input("switch", "value"),
)
# ---------------------------------------
### 6. Run Server
# ---------------------------------------
port = int(os.environ.get("PORT", 8050))

if __name__ == "__main__":
    app.run_server(debug=False, host = "0.0.0.0", port=port)